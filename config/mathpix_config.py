"""
C·∫•u h√¨nh API cho Mathpix
"""
import os
import json
import requests
from dotenv import load_dotenv
from sqlalchemy import true

# Load environment variables
load_dotenv()

class MathpixConfig:
    """C·∫•u h√¨nh cho Mathpix API"""
    
    def __init__(self):
        self.app_key = os.getenv('MATHPIX_APP_KEY')
        self.app_id = os.getenv('MATHPIX_APP_ID')
        self.pdf_base_url = "https://api.mathpix.com/v3/pdf"
        self.text_base_url = "https://api.mathpix.com/v3/text"
        
    def get_headers(self):
        """Tr·∫£ v·ªÅ headers cho Mathpix API"""
        return {
            "app_id": self.app_id,
            "app_key": self.app_key
        }
    
    def is_configured(self):
        """Ki·ªÉm tra xem API ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh ch∆∞a"""
        return bool(self.app_key and self.app_id)
    
    def get_upload_url(self):
        """Tr·∫£ v·ªÅ URL ƒë·ªÉ upload PDF"""
        return self.pdf_base_url
    
    def get_image_url(self):
        """Tr·∫£ v·ªÅ URL ƒë·ªÉ OCR ·∫£nh"""
        return self.text_base_url
    
    def get_status_url(self, pdf_id):
        """Tr·∫£ v·ªÅ URL ƒë·ªÉ check status c·ªßa PDF"""
        return f"{self.pdf_base_url}/{pdf_id}"
    
    def get_download_url(self, pdf_id, format_type="docx"):
        """Tr·∫£ v·ªÅ URL ƒë·ªÉ download file ƒë√£ convert"""
        return f"{self.pdf_base_url}/{pdf_id}.{format_type}"
    
    def ocr_image(self, image_path, options=None):
        """
        OCR m·ªôt ·∫£nh b·∫±ng Mathpix API
        Args:
            image_path: ƒë∆∞·ªùng d·∫´n ƒë·∫øn file ·∫£nh
            options: dict c√°c t√πy ch·ªçn OCR
        Returns:
            dict response t·ª´ API ho·∫∑c None n·∫øu l·ªói
        """
        if not self.is_configured():
            print("‚ùå Mathpix ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh!")
            return None
            
        if not os.path.exists(image_path):
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file ·∫£nh: {image_path}")
            return None
        
        if not self.is_supported_image(image_path):
            print(f"‚ùå Format ·∫£nh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {image_path}")
            print(f"üí° C√°c format ƒë∆∞·ª£c h·ªó tr·ª£: {', '.join(self.get_supported_formats())}")
            return None
        
        # Default options
        default_options = {
            "math_inline_delimiters": ["$", "$"],
            "rm_spaces": True,
        }
        
        if options:
            default_options.update(options)
        
        try:
            print(f"üîÑ ƒêang OCR ·∫£nh: {os.path.basename(image_path)}")
            
            with open(image_path, "rb") as f:
                response = requests.post(
                    self.text_base_url,
                    files={"file": f},
                    data={
                        "options_json": json.dumps(default_options)
                    },
                    headers=self.get_headers()
                )
            
            if response.status_code == 200:
                result = response.json()
                print(f"‚úÖ OCR th√†nh c√¥ng! Confidence: {result.get('confidence', 'N/A')}")
                return result
            else:
                print(f"‚ùå L·ªói API: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"‚ùå L·ªói khi OCR ·∫£nh: {str(e)}")
            return None
    
    def ocr_image_with_custom_options(self, image_path, **kwargs):
        """
        OCR ·∫£nh v·ªõi c√°c t√πy ch·ªçn t√πy ch·ªânh
        Args:
            image_path: ƒë∆∞·ªùng d·∫´n ·∫£nh
            **kwargs: c√°c t√πy ch·ªçn OCR
                - math_inline_delimiters: list delimiters cho math inline
                - math_display_delimiters: list delimiters cho math display  
                - rm_spaces: bool remove extra spaces
                - rm_fonts: bool remove font info
                - numbers_default_to_math: bool convert numbers to math
        """
        return self.ocr_image(image_path, kwargs)
    
    def batch_ocr_images(self, image_paths, options=None):
        """
        OCR nhi·ªÅu ·∫£nh c√πng l√∫c
        Args:
            image_paths: list ƒë∆∞·ªùng d·∫´n ·∫£nh
            options: dict t√πy ch·ªçn OCR
        Returns:
            list k·∫øt qu·∫£ OCR cho t·ª´ng ·∫£nh
        """
        results = []
        
        print(f"üîÑ B·∫Øt ƒë·∫ßu batch OCR {len(image_paths)} ·∫£nh...")
        
        for i, image_path in enumerate(image_paths, 1):
            print(f"\nüìÑ [{i}/{len(image_paths)}] {os.path.basename(image_path)}")
            result = self.ocr_image(image_path, options)
            results.append({
                'image_path': image_path,
                'result': result,
                'success': result is not None
            })
        
        success_count = sum(1 for r in results if r['success'])
        print(f"\n‚úÖ Batch OCR ho√†n th√†nh: {success_count}/{len(image_paths)} th√†nh c√¥ng")
        
        return results
    
    def get_supported_formats(self):
        """Tr·∫£ v·ªÅ list c√°c format ·∫£nh ƒë∆∞·ª£c h·ªó tr·ª£"""
        return ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp']
    
    def get_supported_pdf_formats(self):
        """Tr·∫£ v·ªÅ list c√°c format document ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi PDF API (PDF v√† DOCX)"""
        return ['.pdf', '.docx']
    
    def is_supported_image(self, image_path):
        """Ki·ªÉm tra xem file ·∫£nh c√≥ ƒë∆∞·ª£c h·ªó tr·ª£ kh√¥ng"""
        if not os.path.exists(image_path):
            return False
        
        ext = os.path.splitext(image_path)[1].lower()
        return ext in self.get_supported_formats()
    
    def is_supported_pdf(self, file_path):
        """Ki·ªÉm tra xem file c√≥ ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi PDF API kh√¥ng (PDF ho·∫∑c DOCX)"""
        if not os.path.exists(file_path):
            return False
        
        ext = os.path.splitext(file_path)[1].lower()
        return ext in self.get_supported_pdf_formats()
    
    def is_supported_file(self, file_path):
        """Ki·ªÉm tra xem file c√≥ ƒë∆∞·ª£c h·ªó tr·ª£ kh√¥ng (·∫£nh, PDF, ho·∫∑c DOCX)"""
        return self.is_supported_image(file_path) or self.is_supported_pdf(file_path)
    
    def upload_pdf(self, document_path, options=None):
        """
        Upload document (PDF ho·∫∑c DOCX) ƒë·ªÉ x·ª≠ l√Ω v·ªõi Mathpix API
        Args:
            document_path: ƒë∆∞·ªùng d·∫´n file PDF ho·∫∑c DOCX
            options: dict c√°c t√πy ch·ªçn x·ª≠ l√Ω
        Returns:
            dict response ch·ª©a pdf_id ho·∫∑c None n·∫øu l·ªói
        """
        if not self.is_configured():
            print("‚ùå Mathpix ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh!")
            return None
            
        if not os.path.exists(document_path):
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file: {document_path}")
            return None
        
        if not self.is_supported_pdf(document_path):
            print(f"‚ùå File format kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {document_path}")
            print(f"üí° C√°c format ƒë∆∞·ª£c h·ªó tr·ª£: {', '.join(self.get_supported_pdf_formats())}")
            return None
        
        # Default options for PDF processing - ch·ªâ s·ª≠ d·ª•ng format ƒë∆∞·ª£c h·ªó tr·ª£
        default_options = {
            "conversion_formats": {
                "md": True,      # Markdown format (text)
                "docx": True     # Word format (backup)
            },
            "math_inline_delimiters": ["$", "$"],
            "math_display_delimiters": ["$$", "$$"],
            "rm_spaces": True,
            "enable_tables_fallback": True
        }
        
        if options:
            default_options.update(options)
        
        try:
            print(f"üîÑ ƒêang upload document: {os.path.basename(document_path)}")
            
            with open(document_path, "rb") as f:
                response = requests.post(
                    self.pdf_base_url,
                    files={"file": f},
                    data={
                        "options_json": json.dumps(default_options)
                    },
                    headers=self.get_headers()
                )
            
            if response.status_code == 200:
                result = response.json()
                pdf_id = result.get('pdf_id')
                
                # Debug: in ra response ƒë·ªÉ ki·ªÉm tra
                print(f"üìä Response: {result}")
                
                if pdf_id:
                    print(f"‚úÖ Upload th√†nh c√¥ng! Document ID: {pdf_id}")
                    return result
                else:
                    # Th·ª≠ c√°c key kh√°c c√≥ th·ªÉ ch·ª©a document ID
                    possible_keys = ['id', 'document_id', 'file_id', 'processing_id']
                    for key in possible_keys:
                        if key in result:
                            pdf_id = result[key]
                            print(f"‚úÖ Upload th√†nh c√¥ng! Document ID ({key}): {pdf_id}")
                            # Update result v·ªõi key chu·∫©n
                            result['pdf_id'] = pdf_id
                            return result
                    
                    print(f"‚ùå Kh√¥ng t√¨m th·∫•y Document ID trong response!")
                    print(f"üìã Available keys: {list(result.keys())}")
                    return None
            else:
                print(f"‚ùå L·ªói upload: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"‚ùå L·ªói khi upload document: {str(e)}")
            return None
    
    def check_pdf_status(self, pdf_id):
        """
        Ki·ªÉm tra tr·∫°ng th√°i x·ª≠ l√Ω PDF
        Args:
            pdf_id: ID c·ªßa PDF ƒë√£ upload
        Returns:
            dict response status ho·∫∑c None n·∫øu l·ªói
        """
        if not self.is_configured():
            return None
        
        try:
            response = requests.get(
                self.get_status_url(pdf_id),
                headers=self.get_headers()
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"‚ùå L·ªói check status: {response.status_code}")
                return None
                
        except Exception as e:
            print(f"‚ùå L·ªói khi check status: {str(e)}")
            return None
    
    def download_pdf_result(self, pdf_id, format_type="md"):
        """
        Download k·∫øt qu·∫£ x·ª≠ l√Ω PDF
        Args:
            pdf_id: ID c·ªßa PDF
            format_type: ƒë·ªãnh d·∫°ng output (md, tex, docx)
        Returns:
            text content ho·∫∑c None n·∫øu l·ªói
        """
        if not self.is_configured():
            return None
        
        try:
            response = requests.get(
                self.get_download_url(pdf_id, format_type),
                headers=self.get_headers()
            )
            
            if response.status_code == 200:
                # X·ª≠ l√Ω theo format type
                if format_type in ['md', 'txt']:
                    # Text formats - s·ª≠ d·ª•ng .text
                    return response.text
                elif format_type == 'docx':
                    # Binary format - c·∫ßn x·ª≠ l√Ω ƒë·∫∑c bi·ªát
                    print("‚ö†Ô∏è DOCX format tr·∫£ v·ªÅ binary data, chuy·ªÉn sang markdown...")
                    # Th·ª≠ l·∫°i v·ªõi format markdown
                    return self.download_pdf_result(pdf_id, "md")
                else:
                    # Default: treat as text
                    return response.text
            else:
                print(f"‚ùå L·ªói download: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"‚ùå L·ªói khi download: {str(e)}")
            return None
    
    def process_pdf(self, document_path, timeout=60, check_interval=2):
        """
        X·ª≠ l√Ω document ho√†n ch·ªânh: upload -> wait -> download
        Args:
            document_path: ƒë∆∞·ªùng d·∫´n file PDF ho·∫∑c DOCX
            timeout: th·ªùi gian ch·ªù t·ªëi ƒëa (gi√¢y)
            check_interval: kho·∫£ng th·ªùi gian check status (gi√¢y)
        Returns:
            text content ho·∫∑c None n·∫øu l·ªói
        """
        print(f"üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω document: {os.path.basename(document_path)}")
        
        # Step 1: Upload document
        upload_result = self.upload_pdf(document_path)
        if not upload_result:
            return None
        
        pdf_id = upload_result.get('pdf_id')
        if not pdf_id:
            print("‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c Document ID!")
            return None
        
        # Step 2: Wait for processing
        import time
        elapsed_time = 0
        
        print("‚è≥ ƒêang ch·ªù x·ª≠ l√Ω...")
        while elapsed_time < timeout:
            status_result = self.check_pdf_status(pdf_id)
            
            if status_result:
                status = status_result.get('status', 'unknown')
                print(f"üìä Status: {status} (ƒë√£ ch·ªù {elapsed_time}s)")
                
                if status == 'completed':
                    print("‚úÖ X·ª≠ l√Ω ho√†n th√†nh!")
                    break
                elif status == 'error':
                    print("‚ùå X·ª≠ l√Ω th·∫•t b·∫°i!")
                    return None
            
            time.sleep(check_interval)
            elapsed_time += check_interval
        
        if elapsed_time >= timeout:
            print(f"‚è∞ Timeout sau {timeout}s!")
            return None
        
        # Step 3: Download result  
        print("üì• ƒêang download k·∫øt qu·∫£...")
        
        # Th·ª≠ c√°c format text ƒë∆∞·ª£c h·ªó tr·ª£
        for format_type in ["md", "txt"]:
            print(f"üîÑ Th·ª≠ format: {format_type}")
            result_text = self.download_pdf_result(pdf_id, format_type)
            
            if result_text and not result_text.startswith("PK"):  # Kh√¥ng ph·∫£i binary
                print(f"‚úÖ ƒê√£ nh·∫≠n ƒë∆∞·ª£c k·∫øt qu·∫£ document (format: {format_type})!")
                return result_text
        
        print("‚ùå Kh√¥ng th·ªÉ download k·∫øt qu·∫£ text t·ª´ b·∫•t k·ª≥ format n√†o!")
        return None

# T·∫°o instance global ƒë·ªÉ s·ª≠ d·ª•ng trong to√†n b·ªô ·ª©ng d·ª•ng
mathpix_config = MathpixConfig()